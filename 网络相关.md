tcp/ip 分层
三次握手四次挥手
建立连接的详细过程
http状态吗
https实现
websocket
http2
缓存 强缓存协商缓存 牵扯到ngnix
web安全攻击和防御

**1. 从用户刷新网页开始, 一次 js 请求一般情况下有哪些地方会有缓存处理?**

DNS 缓存(成功访问后网站的域名、IP 地址信息缓存到本地）缓存的是域名对应的真实ip地址

CDN 缓存(内容分发网络,选择一个离用户最近的 CDN 边缘节点来响应用户的请求)，缓存的是离用户最近的cdn服务器地址

浏览器缓存(存储最近访问的过的页面,再次请求时,从本地磁盘显示文档来加速页面的阅览,节约网络的资源加速浏览)，缓存的是资源文件

服务器缓存(将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中,来提高访问速度).缓存的也是资源文件

**14. 优化网站资源的方法**

​ 文件合并（目的是减少 http 请求，头部太重，http2.0可能就不存在这个问题了）: 合并 JavaScript 和 CSS 文 件、CSSSprites、图像映射 (ImageMap,一幅图中多个区域指定不同 url)、使用 DataURI 来编码图片(IE 不支持)、字体图标

​ 文件最小化/文件压缩（目的是直接减少文件下载的体积 服务端开启 gzip）

​ 使用 CDN(内容分发网络) 托管：.通过在网络各处放置节点服务器，CDN 系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息，将用户的请求重新导向离用户最近的服务节点上

​ 缓存的使用:多个域名提供缓存

​

**15. 为什么要利用多个域名来存储网站资源**

> 1.CDN 缓存更方便(内容分发网络,选择一个离用户最近的 CDN 边缘节点来响应用户的请求)

> 2.突破浏览器并发限制，浏览器请求同一域名的资源貌似一次是并发请求6个，如果是多个域名，应该可以突破这个限制

> 3.Cookieless, 节省带宽

> 4.节约主域名的连接数,从而提高客户端网络带宽的利用率,优化页面响应.


**27. post 和 get 如何提交表单？**

​ POST 传递的数据隐藏在 HTTP 报文中，HTTP 协议规范没有对 post 数据量进行大小限制，起限制作用的是服务器的处理程序的处理能力，例如对于 ASP 程序，Request 对象处理每个表单域时存在 100K 的数据长度限制，在 PHP 中，可以用$_POST或$\_REQUEST 获取,在 express 中好像是 body-parser 中间件来取的；

​ GET 请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，参数之间以&相连，HTTP 协议规范没有对 URL 长度进行限制，是特定的浏览器及服务器对它的限制，在 PHP 中，可以用$_GET或$\_REQUEST 获取；

**30.了解 RESTful 接口规范吗？**

> RESTful 不是一种标准，而是一种架构风格，设计风格，提供了一组设计原则和约束规范。

> RESTful 架构的核心规范与约束：统一接口

> > 分为四个子约束：

> > > 1. 每个资源都拥有一个资源标识

> > > 2. 消息的自描述性

> > > 3. 资源的自描述性

> 目的：实现客户端无需借助任何文档即能调用到所有的服务器资源

> 模式：http(s)://server.com/app-name/{version}/{domain}/{rest-convention}


**39. 跨域实现有哪些方式？**

​ JSONP 来实现跨域。

​ 使用 HTML5 中新引进的 window.postMessage 方法来跨域传送数据。

​ 使用 window.name 来进行跨域。

​ 通过修改 document.domain 来跨子域。
 
 服务端设置cors允许前端跨域

 代理服务器配置反向代理实现跨域



**43. http 请求中的 header 信息**

​ F12 调试工具的 network 中，headers 信息包括三个部分：

​ General:

​ **Request URL:**

​ **Request Method:**

​ **Status Code:**

​ **Remote Address:**

​ **Referrer Policy:**

​ Response Headers:

​ **cache-control:缓存策略**

​ **content-encoding:如果为文本、HTML 信息，则使用的编码方式**

​ **content-type:响应的数据类型**

​ **date:当前服务器日期**

​ **last-modified:标名本资料上一次的修改时间**

​ **server:服务器名**

​ **status:状态码**

​ **x-ua-compatible:**

​ Request Headers:

​ **accept-encoding:可接受的文本压缩算法**

​ **accept-language:支持语言，客户端浏览器的设置**

​ **user_Agent:浏览器信息**

​ **cache-control:缓存策略**

​ **cookie:服务器或客户端在上次设置的 COOKIE**

​

**44. sql 注入和 xss 漏洞**

​ sql 注入就是把 sql 命令插入到 web 表单提交或输入域名或页面请求的查询字符串中，欺骗服务器，将恶意的 sql 命令注入到后台数据库引擎执行

​ xss 跨站脚本攻击：通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的

​ xss 攻击常用于：

> > 1. 通过 document.cookie 盗取 cookie

> > 2. 使用 js 或 css 破坏页面正常的结构与样式

> > 3. 流量劫持（通过访问某段具有 window.location.href 定位到其他页面）

> > 4. Dos 攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。

> > 5. 利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。

> > 6. 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。

> xss 防御措施：

> > 1. 编码：不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理，如，对用户输入的数据进行字符实体编码。

> > 2. 解码：原样显示内容的时候必须解码，不然显示不到内容了。

> > 3. 过滤：把输入的一些不合法的东西都过滤掉，如危险标签、属性和事件等，从而保证安全性。如移除用户上传的 DOM 属性，如 onerror 事件，移除用户上传的 Style 节点，iframe, script 节点等。

> > 4. 保护 cookie：对重要的 cookie 设置 httpOnly, 防止客户端通过 document.cookie 读取 cookie。服务端可以设置此字段。

> > 5. js 中避免使用 eval()语句，eval()有把字符串转换为 js 语句的作用。

**62. 协商缓存和强缓存**
强缓存和协商缓存是配合使用的。就是首先匹配强缓存，如果强缓存匹配过期，则会去走协商缓存。缓存是通过在服务器返回相应的文件请求时，在response headers中配置相关的字段来实现的。强缓存在http 1.0是用expire字段，该字段是直接返回一个相对于当时服务器时间的过期时间，浏览器会根据这个时间与自己本地时间比对，如果没有过期，就读取缓存，而如果过期了就发起请求，但是有时服务器的时间和客户端的时间不一定完全一致，这样进行一个时间的比较就难免有时会不一致。所以在http 1.1中用cache-control来控制，返回cache-control:max-age=XXX,直接返回一个过期时间长度，浏览器根据当前的的时间，与这个过期时间及浏览器接收文件的时间做比较，如果过期了就重新请求，这就是强缓存。
如果还配置了协商缓存，那么在重新请求的时候，就会走协商缓存的过程，协商缓存也是可以通过两个字段控制，一个是last-modified,表示的是服务器最后修改这个文件的时间，一个是Etag，是服务器根据文件内容通过算法申城的一个hash值，文件内容如果修改，这个hash值就会改变。如果是用last-modified来控制协商缓存，则会在响应头返回 ，last-modified，表示这个文件最后的修改时间，下次客户端再来请求这个文件，会在请求头上带上if-nodified-since字段，内容就是上次last-modified字段返回的那个事件，服务器根据这个值与服务器中的文件当前的值进行比较，如果在当前的这个时间之前，说明在客户端上次请求之后，服务器中该文件修改过，那么就会返回新的文件给客户端，如果时间一致，那么就返回304告诉客户端读缓存。用Etag来设置缓存，也是类似，服务端返回Etag字段，内容是hash值，下次请求，请求头带上if-none-match去服务器校验。完了之后服务器的返回的响应头会有新的last-modified和Etag值。
这两者比较的话，last-modified的性能好一点，因为它只是记录和比较一个时间节点，而Etag的精准度好一点。两者都设置的话，Etag的优先级更高一点
（补充,cache-control:max-age=XXX,public。这个字段后面还可以配置一个字段，public/immutable/private/...,
    * 如果是public，那么即使max-age的时间还没过期，用户去刷新浏览器，还是会重新发起请求，而如果是设置了immutable,就算用户刷新页面，也不会重新请求，直接在本地磁盘或内存中读缓存并返回200状态,设置了pravite，则表示仅客户端缓存，代理服务器不缓存。如果cache-control直接设no-cache，那么就不设置强缓存了，但不妨碍接下来做协商缓存。如果是设置的no-store,那就是客户端和服务器都不缓存，也就没有所谓的强缓存、协商缓存了）

缓存的优点：

- 减少了不必要的数据传输，节省带宽
- 减少服务器的负担，提升网站性能
- 加快了客户端加载网页的速度
- 用户体验友好

缺点：

- 资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有 bug 的话，情况会更加糟糕

通过设置 respone header 的 cache-control 字段来设置：
如果你只设置了 cahe-control:max-age=315360000,public 这属于强缓存，每次用户正常打开这个页面，浏览器会判断缓存是否过期，没有过期就从缓存中读取数据；但是有一些 "聪明" 的用户会点击浏览器左上角的刷新按钮去刷新页面，这时候就算资源没有过期（10 年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了（下面会讲到）。如果 cahe-control:max-age=315360000,public 再加个 immutable 的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回 200 状态

强缓存总结:
cache-control: max-age=xxxx，public
客户端和代理服务器都可以缓存该资源；
客户端在 xxx 秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起 http 请求

    只让客户端可以缓存该资源；代理服务器不缓存
    客户端在xxx秒内直接读取缓存,statu code:200

    cache-control: max-age=xxxx，private
    cache-control: max-age=xxxx，immutable
    客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

    cache-control: no-cache
    跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

    cache-control: no-store
    不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。

怎么设置协商缓存？

    response header里面的设置:

    etag: '5c20abbd-e2e8'
    last-modified: Mon, 24 Dec 2018 09:49:49 GMT
    etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一    hash，也是为了解决缓存问题。

    last-modified：文件的修改时间，精确到秒

    也就是说，每次请求返回来 response header 中的 etag和 last-modified，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更    改了，如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都   是要进行协商缓存了，即：

    发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。

    这就是一条完整的协商缓存的过程。

    当然，当服务端发现资源真的过期的时候，会走如下流程：

    发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、    etag、last-modified等。

    所以协商缓存步骤总结：

    请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
    如果资源没更改，返回304，浏览器读取本地缓存。
    如果资源有更改，返回200，返回最新的资源。

    补充一点，response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：
    // response header
    etag: '5c20abbd-e2e8'
    last-modified: Mon, 24 Dec 2018 09:49:49 GMT

    // request header 变为
    if-none-matched: '5c20abbd-e2e8'
    if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT


**70. 推流和拉流？**

> ​ 流媒体，采用流式传输的媒体格式，商家用视频传送服务器，将节目当成数据包传送到网络上，用户通过解压设备对这些数据解压，节目就会像压缩前一样可以播放，也就是边传边播，

> ​ 推流，就是把封包好的内容传输到服务器的过程，拉流，就是在服务器已有直播内容后，用指定地址进行拉取的过程。

> ​ 主流的推送协议：WebRTC、HLS、RTMP

> ​ \- Web RTC（Web Real-Time Communication），网页即时通信，是一个支持浏览器进行实时语音，视频对话的开源协议，支持者很多，Google，Mozilla，Opera 等浏览器厂商的推动使它成为 W3C 推荐标准。

> ​ \- HLS（Http Live Streaming）是苹果公司定义的基于 HTTP 的流媒体实时传输协议。原理是将整个流分为多个小文件下载，每次下载若干个，服务器端将最新的直播数据生成新的小文件，客户端不停的按顺序播放获取到的文件，就实现了直播。分段推送的特点就是延迟比较高，数据通过 HTTP 协议传输，不用担心防火墙或代理的问题。

> ​ \- RTMP（Real Time Messaging Protocol），实时消息传输协议，ADOBE 公司开发，是目前最主流的流媒体传输协议，是大多数直播平台的选择，但不支持浏览器。

> ​

> ​

**71. 即时通信了解多少？**

> ​ Web 即时通信方式主要有四种：

1.短轮询:

> ​ 浏览器每隔一段时间像服务器端发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。特点；不断的建立 http 连接，严重浪费了服务器端和客户端的资源。

2.长轮询（comet）:

> ​ 服务器收到客户端发来的请求后，不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)后关闭连接。

3.SSE:

> ​ SSE 是 HTML5 新增的功能，全称为 Server-SentEvents。它可以允许服务推送数据到客户端。

4.WebSocket:

> ​ WebSocket 是 HTML5 定义的一个新协议，与传统的 http 协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要 http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。

**106. AJAX 状态值**

​ 0: (未初始化)还没有调用 send()方法。

​ 1: (载入)已经调用 send()方法，正在派发请求。

​ 2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。

​ 3: (交互)正在解析响应内容。

​ 4: (完成)响应内容已经解析完成，用户可以调用。

​

**107. HTTP 状态码**
http的状态吗分为5个类别，通过最高位的1到5类分类，让我们能够不用通过文本直接通过状态码就简单直观地了解到一次请求的结果。
1xx表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程；
2xx表示成功接受请求并已完成整个处理过程
3xx表示为完成请求，客户端需要进一步细化请求，3xx印象中一直是走缓存的，这里有待进一步了解
4xx表示客户端的请求有错误，常见的404notfound，403forbiden
5xx一般表示服务端出现错误，常见500 

​ 200： 请求已成功,请求所希望的响应头或数据体将随此响应返回

​ 302： 请求的资源临时从不同的 URL 响应请求.

​ 304： 发送了请求且被允许，但文档内容没有改变，不会重新加载，返回 304

​ 403： 服务器已经理解请求,但是拒绝执行它.

​ 404： 请求失败,请求所希望得到的资源未被在在服务器上发现.

​ 500： 服务器遇到了一个未曾预料的状况，一般是服务器源代码出错



**110. cookie 和 session 的关系，禁用 cookie 还能使用 session 么？**

session 的 id 存在 cookie 中，但 session 不一定依赖 cookie，禁用 cookie 时，session 的 id 可以通过 url 传递，或者通过隐藏的表单来传递到服务器

session，cookie这个必须搞懂，光凭现在的认知是不能说服别人的！

**108.配置过nginx吗**
嗯，我在自己的电脑上配置过，对ng的配置有一些基本的了解。它主要的作用大致有三个，反向代理，负载均衡，缓存.它的配置主要是在http，server，location，这些嵌套的块中配置，
http中有配置gzip，配置多个虚拟主机，一个server对应一个虚拟主机。反向代理proxy_pass,将匹配到的请求转发到要代理的服务器地址上，跟我们在webpack-dev-server中配置proxyTable基本是一样的。它还有一个重要的功能就是配置多台服务器的负载均衡，将负载分摊到多个服务器上执行，从而提高服务的可用性和响应速度。主要的配置方法有通过轮询来配置，就是按照请求的时间轮流去分配目标服务器，在这基础上还有加权轮询，就是不仅按照时间轮流分配，还可以通过weight配置服务器对应的权重，这样可以让硬件配置更高的服务器承担更大的工作量，还有个通过请求访问的ip_hash来分配的，这个不是很了解。缓存的话就是我们常用的强缓存配合协商缓存。通过proxy_store...这块还得再结合掘金文章详细整理一下

**111.代理和反向代理**
代理代理的是服务器，反向代理代理的是客户端
一开是我们把打包编译的文件，放在express下面的public去静态托管，现在用ng之后，我们把前端打包出来的文件，放到ng的static中，起起ng服务，其实就类似express的静态托管，当然ng貌似牛逼一些. 假如ng起的服务是4396端口，那我们前端的baseurl就是4396.而我们的后端服务也就是express是起在4397端口的，前端代码访问的也是往4397访问。这就是4396访问4397就是跨域了，ng配允许跨域貌似没用？反正现在还是在express的所有服务前设置允许跨域的